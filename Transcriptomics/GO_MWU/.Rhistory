# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)
?lattice
Version(lattice)
packageVersion("lattice")
# 2. QC - outlier detection ------------------------------------------------
# detect outlier genes
gsg <- goodSamplesGenes(t(countsTable))
summary(gsg)
gsg$allOK
table(gsg$goodGenes)
table(gsg$goodSamples)
# detect outlier samples - hierarchical clustering - method 1
htree <- hclust(dist(t(countsTable)), method = "average")
plot(htree)
# pca - method 2
pca <- prcomp(t(countsTable))
pca.dat <- pca$x
pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)
pca.dat <- as.data.frame(pca.dat)
ggplot(pca.dat, aes(PC1, PC2)) +
geom_point() +
geom_text(label = rownames(pca.dat)) +
labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
y = paste0('PC2: ', pca.var.percent[2], ' %'))
table(gsg$goodGenes)
table(gsg$goodSamples)
?goodSamplesGenes
# 3. Normalization ----------------------------------------------------------------------
colData <- row.names(sample_metadata)
# making the rownames and column names identical
all(rownames(colData) %in% colnames(countsTableRound)) # to see if all samples are present in both
all(rownames(colData) == colnames(countsTableRound))  # to see if all samples are in the same order
# perform variance stabilization
dds_norm <- vst(dds)
# dds_norm <- vst(normalized_counts)
# get normalized counts
norm.counts <- assay(dds_norm) %>%
t()
# 4. Network Construction  ---------------------------------------------------
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))
# Call the network topology analysis function; this step takes a couple minutes
sft <- pickSoftThreshold(norm.counts,
powerVector = power,
networkType = "signed",
verbose = 5)
sft.data <- sft$fitIndices
# visualization to pick power
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
geom_hline(yintercept = 0.8, color = 'red') +
labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
theme_classic()
a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
labs(x = 'Power', y = 'Mean Connectivity') +
theme_classic()
grid.arrange(a1, a2, nrow = 2)
# based on this plot, choose a soft power to maximize R^2 (above 0.8) and minimize connectivity
# for these ahud data: 6-8; Higher R2 should yield more modules.
# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
soft_power <- 6
temp_cor <- cor
cor <- WGCNA::cor # use the 'cor' function from the WGCNA package
# this step also takes a few minutes; ideally your maxBlockSize is larger than your number of genes to run the memory-intensive network construction all at once.
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 26000,
minModuleSize = 30,
reassignThreshold=0,
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25,
numericLabels = F,
randomSeed = 1234,
verbose = 3)
# TOMtype (Topological Overlap Matrix type) parameter - unsigned - doesn't consider positive/negative co-expression
# signed - when you want to consider the direction of co-expression interaction, e.g., activating or inhibiting
# WGCNA often uses a dendrogram-based approach to identify modules. The choice of the
# height cut in the dendrogram can determine the number of modules. Selecting a higher
# cut height results in fewer, larger modules, while a lower cut height leads to more,
# smaller modules.
cor <- temp_cor
module_eigengenes <- bwnet$MEs
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# grey module = all genes that doesn't fall into other modules were assigned to the grey module
# with higher soft power, more genes fall into the grey module
# 6A. Relate modules to traits --------------------------------------------------
# module trait associations
traits <- sample_metadata[, c(5,8,11,14,17)]
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
names(heatmap.data)
CorLevelPlot(heatmap.data,
x = names(heatmap.data)[12:16],
y = names(heatmap.data)[1:11],
col = c("blue1", "skyblue", "white", "pink", "red"))
module.gene.mapping <- as.data.frame(bwnet$colors) # assigns module membership to each gene
module.gene.mapping %>%
filter(`bwnet$colors` == 'yellow') %>%
rownames()
groups <- sample_metadata[,c(3,1)]
module_eigengene.metadata <- merge(groups, heatmap.data, by = 'row.names')
#Create a summary data frame of a particular module eigengene information
MEyellow_summary <- summarySE(module_eigengene.metadata, measurevar="MEyellow", groupvars=c("Generation","treatment"))
#Plot a line interaction plot of a particular module eigengene
ggplot(MEyellow_summary, aes(x=as.factor(Generation), y=MEyellow, color=treatment, fill = treatment, shape = treatment)) +
geom_point(size=5, stroke = 1.5 ) +
geom_errorbar(aes(ymin=MEyellow-se, ymax=MEyellow+se), width=.15) +
geom_line(aes(color=treatment, group=treatment, linetype = treatment)) +
scale_color_manual(values = c('#6699CC',"#F2AD00","#00A08A", "#CC3333")) +
scale_shape_manual(values=c(21,22,23,24), labels = c("Ambient", "Acidification","Warming", "OWA"))+
scale_fill_manual(values=c('#6699CC',"#F2AD00","#00A08A", "#CC3333"), labels = c("Ambient", "Acidification","Warming", "OWA"))+
xlab("Generation") +
theme_bw() +
theme(legend.position = "none") +
theme(panel.border = element_rect(color = "black", fill = NA, size = 4))+
theme(text = element_text(size = 20)) +
theme(panel.grid.minor.y = element_blank(), legend.position = "none", plot.margin = margin(0,6,0,6))
# 6B. Intramodular analysis: Identifying driver genes ---------------
# Get top hub genes (genes with highest connectivity in the network)
hubs  <-  chooseTopHubInEachModule(norm.counts, bwnet$colors, type = "signed", omitColors = "")
hubs
### Plot Individual genes  to check! ###
d <-plotCounts(dds, gene="TRINITY_DN11845_c0_g1::TRINITY_DN11845_c0_g1_i9::g.36434::m.36434", intgroup = (c("treatment","Generation")), returnData=TRUE)
d_summary <- summarySE(d, measurevar = "count", groupvars=c("Generation","treatment"))
ggplot(d_summary, aes(x=Generation, y=count, color=treatment, fill = treatment, shape = treatment)) +
geom_point(size=5, stroke = 1.5 ) +
geom_errorbar(aes(ymin=count-se, ymax=count+se), width=.15) +
geom_line(aes(color=treatment, group=treatment, linetype = treatment)) +
scale_color_manual(values = c('#6699CC',"#F2AD00","#00A08A", "#CC3333")) +
scale_shape_manual(values=c(21,22,23,24), labels = c("Ambient", "Acidification","Warming", "OWA"))+
scale_fill_manual(values=c('#6699CC',"#F2AD00","#00A08A", "#CC3333"), labels = c("Ambient", "Acidification","Warming", "OWA"))+
xlab("Generation") +
theme_bw() +
theme(legend.position = "none") +
theme(panel.border = element_rect(color = "black", fill = NA, size = 4))+
theme(text = element_text(size = 20)) +
theme(panel.grid.minor.y = element_blank(), legend.position = "none", plot.margin = margin(0,6,0,6))
# Calculate the module membership and the associated p-values
# The module membership/intramodular connectivity is calculated as the correlation of the eigengene and the gene expression profile.
# This quantifies the similarity of all genes on the array to every module.
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)
module.membership.measure.pvals[1:10,1:10]
# Calculate the module membership and the associated p-values
# The module membership/intramodular connectivity is calculated as the correlation of the eigengene and the gene expression profile.
# This quantifies the similarity of all genes on the array to every module.
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)
module.membership.measure.pvals[1:10,1:10]
# Make a heat map of gene expressions within modules.
# Use the norm.counts matrix, subset based on module membership
t_norm.counts <- norm.counts %>% t() %>% as.data.frame()
# Yellow module
yellow_transcripts <- module.gene.mapping %>%
filter(`bwnet$colors` == 'yellow') %>%
rownames()
t_norm.counts_yellow <- t_norm.counts %>%
filter(row.names(t_norm.counts) %in% yellow_transcripts)
t_norm.counts_yellow <- t_norm.counts_yellow - rowMeans(t_norm.counts_yellow)
df <- as.data.frame(colData(dds)[,c("eneration","treatment")])
# Make a heat map of gene expressions within modules.
# Use the norm.counts matrix, subset based on module membership
t_norm.counts <- norm.counts %>% t() %>% as.data.frame()
# Yellow module
yellow_transcripts <- module.gene.mapping %>%
filter(`bwnet$colors` == 'yellow') %>%
rownames()
t_norm.counts_yellow <- t_norm.counts %>%
filter(row.names(t_norm.counts) %in% yellow_transcripts)
t_norm.counts_yellow <- t_norm.counts_yellow - rowMeans(t_norm.counts_yellow)
df <- as.data.frame(colData(dds)[,c("eneration","treatment")])
colData(dds)
df <- as.data.frame(colData(dds)[,c("Generation","treatment")])
#blue to yellow color scheme
paletteLength <- 50
myColor <- colorRampPalette(c("dodgerblue", "black", "yellow"))(paletteLength)
myBreaks <- c(seq(min(t_norm.counts_yellow), 0, length.out=ceiling(paletteLength/2) + 1),
seq(max(t_norm.counts_yellow)/paletteLength, max(t_norm.counts_yellow), length.out=floor(paletteLength/2)))
pheatmap(t_norm.counts_yellow, color = myColor, breaks = myBreaks,
show_colnames = FALSE, show_rownames = FALSE, annotation_col = df, main = "Yellow")
traits <- sample_metadata[, c(5,8,11,14,17)]
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
names(heatmap.data)
CorLevelPlot(heatmap.data,
x = names(heatmap.data)[12:16],
y = names(heatmap.data)[1:11],
col = c("blue1", "skyblue", "white", "pink", "red"))
module.gene.mapping <- as.data.frame(bwnet$colors) # assigns module membership to each gene
module.gene.mapping %>%
filter(`bwnet$colors` == 'yellow') %>%
rownames()
groups <- sample_metadata[,c(3,1)]
module_eigengene.metadata <- merge(groups, heatmap.data, by = 'row.names')
#Create a summary data frame of a particular module eigengene information
MEyellow_summary <- summarySE(module_eigengene.metadata, measurevar="MEyellow", groupvars=c("Generation","treatment"))
#Plot a line interaction plot of a particular module eigengene
ggplot(MEyellow_summary, aes(x=as.factor(Generation), y=MEyellow, color=treatment, fill = treatment, shape = treatment)) +
geom_point(size=5, stroke = 1.5 ) +
geom_errorbar(aes(ymin=MEyellow-se, ymax=MEyellow+se), width=.15) +
geom_line(aes(color=treatment, group=treatment, linetype = treatment)) +
scale_color_manual(values = c('#6699CC',"#F2AD00","#00A08A", "#CC3333")) +
scale_shape_manual(values=c(21,22,23,24), labels = c("Ambient", "Acidification","Warming", "OWA"))+
scale_fill_manual(values=c('#6699CC',"#F2AD00","#00A08A", "#CC3333"), labels = c("Ambient", "Acidification","Warming", "OWA"))+
xlab("Generation") +
theme_bw() +
theme(legend.position = "none") +
theme(panel.border = element_rect(color = "black", fill = NA, size = 4))+
theme(text = element_text(size = 20)) +
theme(panel.grid.minor.y = element_blank(), legend.position = "none", plot.margin = margin(0,6,0,6))
# Get top hub genes (genes with highest connectivity in the network)
hubs  <-  chooseTopHubInEachModule(norm.counts, bwnet$colors, type = "signed", omitColors = "")
hubs
d <-plotCounts(dds, gene="TRINITY_DN11845_c0_g1::TRINITY_DN11845_c0_g1_i9::g.36434::m.36434", intgroup = (c("treatment","Generation")), returnData=TRUE)
d_summary <- summarySE(d, measurevar = "count", groupvars=c("Generation","treatment"))
ggplot(d_summary, aes(x=Generation, y=count, color=treatment, fill = treatment, shape = treatment)) +
geom_point(size=5, stroke = 1.5 ) +
geom_errorbar(aes(ymin=count-se, ymax=count+se), width=.15) +
geom_line(aes(color=treatment, group=treatment, linetype = treatment)) +
scale_color_manual(values = c('#6699CC',"#F2AD00","#00A08A", "#CC3333")) +
scale_shape_manual(values=c(21,22,23,24), labels = c("Ambient", "Acidification","Warming", "OWA"))+
scale_fill_manual(values=c('#6699CC',"#F2AD00","#00A08A", "#CC3333"), labels = c("Ambient", "Acidification","Warming", "OWA"))+
xlab("Generation") +
theme_bw() +
theme(legend.position = "none") +
theme(panel.border = element_rect(color = "black", fill = NA, size = 4))+
theme(text = element_text(size = 20)) +
theme(panel.grid.minor.y = element_blank(), legend.position = "none", plot.margin = margin(0,6,0,6))
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)
module.membership.measure.pvals[1:10,1:10]
# Make a heat map of gene expressions within modules.
# Use the norm.counts matrix, subset based on module membership
t_norm.counts <- norm.counts %>% t() %>% as.data.frame()
# Yellow module
yellow_transcripts <- module.gene.mapping %>%
filter(`bwnet$colors` == 'yellow') %>%
rownames()
t_norm.counts_yellow <- t_norm.counts %>%
filter(row.names(t_norm.counts) %in% yellow_transcripts)
t_norm.counts_yellow <- t_norm.counts_yellow - rowMeans(t_norm.counts_yellow)
df <- as.data.frame(colData(dds)[,c("Generation","treatment")])
#blue to yellow color scheme
paletteLength <- 50
myColor <- colorRampPalette(c("dodgerblue", "black", "yellow"))(paletteLength)
myBreaks <- c(seq(min(t_norm.counts_yellow), 0, length.out=ceiling(paletteLength/2) + 1),
seq(max(t_norm.counts_yellow)/paletteLength, max(t_norm.counts_yellow), length.out=floor(paletteLength/2)))
pheatmap(t_norm.counts_yellow, color = myColor, breaks = myBreaks,
show_colnames = FALSE, show_rownames = FALSE, annotation_col = df, main = "Yellow")
View(traits)
View(sample_metadata)
library(RcppCNPy) # for reading python numpy (.npy) files
setwd("~/Documents/Github/Ecological_Genomics/Fall_2023/pcangsd/")
list.files()
### read in selection statistics (these are chi^2 distributed)
s<-npyLoad("allRS_poly.selection.npy")
# convert test statistic to p-value
pval <- as.data.frame(1-pchisq(s,1))
names(pval) = "p_PC1"
## read positions
p <- read.table("allRS_poly_mafs.sites",sep="\t",header=T, stringsAsFactors=T)
## read positions
p <- read.table("allRS_poly_mafs.sites",sep="\t",header=T, stringsAsFactors=T)
dim(p)
p_filtered = p[which(p$kept_sites==1),]
dim(p_filtered)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)")
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)")
?plot
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5)
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5,
xlim=c(0,1e5))
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5,
xlim=c(0,1e5))
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
ces=0.5,
xlim=c(0,1e5))
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
cex=0.5,
xlim=c(0,1e5))
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
cex=0.25,
xlim=c(0,1e5))
## make manhattan plot
plot(-log10(pval$p_PC1),
col=p_filtered$chromo,
xlab="Position",
ylab="-log10(p-value)",
main="Selection outliers: pcANGSD e=1 (K2)",
cex=0.25)
setwd("/Users/stephenkeller/Documents/GitHub/Ecological_Genomics_23/Transcriptomics/GOMWU/")
library(DESeq2)
# Try with new counts table from filtered transcriptome assembly
countsTable <- read.table("salmon.isoform.counts.matrix.filteredAssembly", header=TRUE, row.names=1)
setwd("/Users/stephenkeller/Documents/GitHub/Ecological_Genomics_23/Transcriptomics/")
setwd("/Users/stephenkeller/Documents/GitHub/Ecological_Genomics_23/Transcriptomics/")
# Try with new counts table from filtered transcriptome assembly
countsTable <- read.table("results/salmon.isoform.counts.matrix.filteredAssembly", header=TRUE, row.names=1)
# Try with new counts table from filtered transcriptome assembly
countsTable <- read.table("data/salmon.isoform.counts.matrix.filteredAssembly", header=TRUE, row.names=1)
head(countsTable)
dim(countsTable)
countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)
#import the sample discription table
conds <- read.delim("ahud_samples_R.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
#import the sample discription table
conds <- read.delim("data/ahud_samples_R.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds,
design= ~ treatment)
dim(dds)
# Filter
dds <- dds[rowSums(counts(dds) >= 30) >= 28,]
nrow(dds)
# Subset the DESeqDataSet to the specific level of the "generation" factor
dds_F0 <- subset(dds, select = generation == 'F0')
dim(dds_F0)
# Perform DESeq2 analysis on the subset
dds_F0 <- DESeq(dds_F0)
resultsNames(dds_F0)
res_F0_OWvAM <- results(dds_F0, name="treatment_OW_vs_AM", alpha=0.05)
res_F0_OWvAM <- res_F0_OWvAM[order(res_F0_OWvAM$padj),]
head(res_F0_OWvAM)
summary(res_F0_OWvAM)
res_F0_OWAvAM <- results(dds_F0, name="treatment_OWA_vs_AM", alpha=0.05)
res_F0_OWAvAM <- res_F0_OWAvAM[order(res_F0_OWAvAM$padj),]
head(res_F0_OWAvAM)
summary(res_F0_OWAvAM)
res_F0_OAvAM <- results(dds_F0, name="treatment_OA_vs_AM", alpha=0.05)
res_F0_OAvAM <- res_F0_OAvAM[order(res_F0_OAvAM$padj),]
head(res_F0_OAvAM)
summary(res_F0_OAvAM)
library(tidyr)
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWvAM_df <- data.frame(transcriptID = rownames(res_F0_OWvAM), res_F0_OWvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWvAM_df <- separate(res_F0_OWvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWvAM_df$transcriptID_trim <- paste(res_F0_OWvAM_df$part1, res_F0_OWvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWvAM_df <- res_F0_OWvAM_df[, !(names(res_F0_OWvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWvAM_df, file = "res_F0_OWvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OW <- res_F0_OWvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OW, file = "res_F0_OWvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWAvAM_df <- data.frame(transcriptID = rownames(res_F0_OWAvAM), res_F0_OWAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWAvAM_df <- separate(res_F0_OWAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWAvAM_df$transcriptID_trim <- paste(res_F0_OWAvAM_df$part1, res_F0_OWAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWAvAM_df <- res_F0_OWAvAM_df[, !(names(res_F0_OWAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWAvAM_df, file = "res_F0_OWAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OWA <- res_F0_OWAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OWA, file = "res_F0_OWAvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
write.table(res_F0_OWvAM_df, file = "GO_MWU/res_F0_OWvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Save the selected columns as a CSV file
write.csv(selected_columns_OW, file = "GO_MWU/res_F0_OWvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OWAvAM_df <- data.frame(transcriptID = rownames(res_F0_OWAvAM), res_F0_OWAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OWAvAM_df <- separate(res_F0_OWAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OWAvAM_df$transcriptID_trim <- paste(res_F0_OWAvAM_df$part1, res_F0_OWAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OWAvAM_df <- res_F0_OWAvAM_df[, !(names(res_F0_OWAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OWAvAM_df, file = "GO_MWU/res_F0_OWAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OWA <- res_F0_OWAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OWA, file = "GO_MWU/res_F0_OWAvAM_LFC.csv", quote = FALSE, row.names = F) # saves the selected columns for GOMWU
# Make the rownames a separate column called transcriptID and make it all a dataframe
res_F0_OAvAM_df <- data.frame(transcriptID = rownames(res_F0_OAvAM), res_F0_OAvAM)
# Split the "transcriptID" column by double colons and create new columns of the parts
res_F0_OAvAM_df <- separate(res_F0_OAvAM_df, transcriptID, into = c("part1", "part2", "part3", "rest"), sep = "::", remove = FALSE)
# Create a new column by concatenating "part1" and "part2" with double colons in between
res_F0_OAvAM_df$transcriptID_trim <- paste(res_F0_OAvAM_df$part1, res_F0_OAvAM_df$part2, sep = "::")
# Optional: Remove the "part1" and "part2" columns from the dataframe
res_F0_OAvAM_df <- res_F0_OAvAM_df[, !(names(res_F0_OAvAM_df) %in% c("part1", "part2", "part3", "rest"))]
write.table(res_F0_OAvAM_df, file = "GO_MWU/res_F0_OAvAM.txt", sep = "\t", row.names = F)   # saves the full original for the records
# Select the two columns we want to save for the GOMWU analysis
selected_columns_OA <- res_F0_OAvAM_df[c("transcriptID_trim", "log2FoldChange")]
# Save the selected columns as a CSV file
write.csv(selected_columns_OA, file = "GO_MWU/res_F0_OAvAM_LFC.csv", quote = FALSE, row.names = F)
getwd()
################################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.
setwd("/Users/stephenkeller/Documents/GitHub/Ecological_Genomics_23/Transcriptomics/GO_MWU/")
# Edit these to match your data file names:
input="res_F0_OWvAM_LFC.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="trinotate_annotation_GOblastx_onlyanns_onlyGOs_justmergeGeneIDtab34.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.05,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=10,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
?install.packages
install.packages("adegenet",lib="~/Downloads")
